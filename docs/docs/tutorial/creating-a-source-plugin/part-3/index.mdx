---
title: "Part 3: Define the GraphQL Schema"
---

import { LinkButton } from "gatsby-interface"
import Collapsible from "@components/collapsible"
import { MdArrowForward } from "react-icons/md"

## Introduction

In the last part you learned how to create GraphQL nodes and use them in your site. In this part you'll dive deeper into the GraphQL schema creation process and learn how to modify the schema. This knowledge will be valuable for the reliability and usability of your plugin.

In this part of the tutorial, you'll learn how to use the [`createSchemaCustomization` Node API](/docs/reference/config-files/gatsby-node/#createSchemaCustomization).

By the end of this part of the tutorial, you will be able to:

- Understand how Gatsby automatically creates GraphQL types
- Explicitly define the GraphQL schema for your plugin
- Create a foreign-key relationship between your `Post` and `Author` nodes

## Automatic type inference

Before explaining how you can explicitly define your GraphQL schema, it's important for you to understand how Gatsby's automatic type inference works. It'll then make more sense why you'd want to define a schema manually and what benefits you'll receive.

One of Gatsby’s main strengths is the ability to query data from a variety of sources in a uniform way with GraphQL. For this to work, a GraphQL schema must be generated that defines the shape of the data. Gatsby is able to automatically infer a GraphQL Schema from your data, and in many cases, this is really all you need. There are however situations when you either want to explicitly define the data shape, or add custom functionality to the query layer — this is what Gatsby’s `createSchemaCustomization` API provides.

In order to translate the data shape into GraphQL type definitions, Gatsby has to inspect the contents of every field and check its type. There is a big problem with this approach though: If the values on a field are of different types, Gatsby cannot decide which one is the correct one. A consequence of this is that if your data sources change, type inference could suddenly fail. For example, this could happen when data from your source is optional and thus can sometimes exist, sometimes not exist.

The diagram below shows how inference works:

![Overview of how GraphQL inference works in Gatsby. Extended description below.](./01-graphql-inference.png)

<Collapsible
  summary={<em>Expand for detailed description</em>}
>

You source your incoming data, for example the `Post` information:

```json
{
  slug: 'post-1',
  title: 'The first post',
  image: {
    url: 'https://images.unsplash.com/photo-1615751072497-5f5169febe17?fm=jpg',
    alt: 'brown and white long coated dog',
    width: 3024,
    height: 4032
  },
  author: 'Jay Gatsby'
}
```

When you pass this data through `createNode` (as shown in [Part 2](/docs/tutorial/creating-a-source-plugin/part-2/)) Gatsby inspects the data and tries to figure out ("infer") the appropriate GraphQL types. So a JavaScript `String` becomes a GraphQL `String`, a JavaScript `Number` becomes an `Int`, and a JavaScript object becomes a new GraphQL type.

The `Post` will be translated to this:

```graphql
type Post implements Node {
  slug: String
  title: String
  image: PostImage
  author: String
}

type PostImage {
  url: String
  alt: String
  width: Int
  height: Int
}
```

</Collapsible>

Now let's imagine that not every key on the `Post` input data is always given. There could be an additional, new field called `subTitle` on the `Post` input. Not every post will have a subtitle, therefore it's an optional field.

The diagram below shows the problem with inference when data has optional fields:

![Overview how inference errors happen. Extended description below.](./02-optional-fields-inference.png)

<Collapsible
  summary={<em>Expand for detailed description</em>}
>

On the first run the incoming data has `title` and `subTitle` so Gatsby also infers both fields for its `Post` GraphQL type. You can then query it in your page/static queries and expect it to exist in the schema.

But on the second run the `subTitle` was removed from the data and as a consequence Gatsby didn't infer this field. `subTitle` now doesn't exist in the `Post` GraphQL type, but in the GraphQL query you're still trying to query it. This leads to an error where Gatsby complains that it can't find the field.

The error would be something like this (in your terminal):

```shell
There was an error in your GraphQL query:

Cannot query field "subTitle" on type "Post".
```

</Collapsible>

So while you know that `subTitle` is optional, Gatsby can't automatically infer this. Therefore you'll need to help Gatsby interpret your data and define the GraphQL schema — which you'll learn in the next step.

## Explicitly define your GraphQL schema

To best support [Valhalla Content Hub](/products/valhalla-content-hub) you'll be **required** to explicitly define the GraphQL schema for your source plugin. This way the pitfalls you've read above won't occur. In general, it's considered best practice to define types as it adds reliablity and usability to your plugin.

Without further ado, add a new file called `create-schema-customization.ts` to the plugin with the following contents:

```ts:title=plugin/src/create-schema-customization.ts
import type { GatsbyNode } from "gatsby"

export const createSchemaCustomization: GatsbyNode[`createSchemaCustomization`] =
  ({ actions }) => {
    const { createTypes } = actions
  }
```

Add the new `createSchemaCustomization` export to the `gatsby-node.ts` file so that it gets executed:

```ts:title=plugin/src/gatsby-node.ts
export type { IPluginOptions } from "./types"

export { onPluginInit } from "./on-plugin-init"
export { sourceNodes } from "./source-nodes"
// highlight-next-line
export { createSchemaCustomization } from "./create-schema-customization"
```

### `createTypes`

Before using [`createTypes`](/docs/reference/config-files/actions/#createTypes), here are some things to note for its usage:

- Type definitions can be provided either in GraphQL's [schema definition language (SDL)](https://graphql.org/learn/schema/), Gatsby Type Builders, or a combination of both. You'll use the SDL syntax for the rest of this tutorial but you can also read an example for Gatsby's Type Builder syntax in this part.
- By default, explicit type definitions you add with `createTypes` will be merged with inferred field types. So if you only want to define a subset of fields, the rest will be inferred as before. You can modify this behavior with the `@infer` and `@dontInfer` directives. You'll learn more about directives in [Add a foreign-key relationship](#add-a-foreign-key-relationship).
- Type definitions targeting root node types, e.g. `MarkdownRemark` or others added in `sourceNodes`/`onCreateNode` like `Post` and `Author`, need to implement the `Node` interface. You can do this by adding the `implements Node` to the SDL.

As an example, this is the incoming data to `createNode` that gets inspected and inferred:

```json
{
  "name": "Gatsby",
  "address": {
    "street": "Some street",
    "city": "San Francisco",
    "state": "California",
  }
}
```

Since `state` is not always given you want to explicitly define it. As `street` will always be defined, you can mark it as [Non-Null](https://graphql.org/learn/schema/#lists-and-non-null) with a `!`. `city` will be automatically inferred and merged with the custom types.

```ts
import type { GatsbyNode } from "gatsby"

export const createSchemaCustomization: GatsbyNode[`createSchemaCustomization`] =
  ({ actions }) => {
    const { createTypes } = actions

    createTypes(`
      type User implements Node {
        address: UserAddress
      }

      type UserAddress {
        street: String!
        state: String
      }
    `)
  }
```

In this example the `User` type is a root node type, so you'll be able to query it with `allUser` and `user` in GraphQL.

<Collapsible
  summary={<em>Gatsby Type Builder example</em>}
>

In many cases, GraphQL SDL provides a succinct way to provide type definitions for your schema. If however you need more flexibility, `createTypes` also accepts type definitions provided with the help of Gatsby Type Builders, which are more flexible than SDL syntax. They are accessible on the `schema` argument passed to Node APIs.

```ts
import type { GatsbyNode } from "gatsby"

export const createSchemaCustomization: GatsbyNode[`createSchemaCustomization`] =
  ({ actions, schema }) => {
    const { createTypes } = actions

    const typeDefs = [
      schema.buildObjectType({
        name: `User`,
        interfaces: [`Node`],
        fields: {
          address: `UserAddress`,
        },
      }),
      schema.buildObjectType({
        name: `UserAddress`,
        fields: {
          street: {
            type: `String!`,
          },
          state: `String`,
        },
      }),
    ]

    createTypes(typeDefs)
  }
```

</Collapsible>

### Task: Add types for `Post` and `Author`

Going back to your `create-schema-customization.ts` file, begin writing out the GraphQL types inside `createTypes`. Start by creating the root node types:

```ts:title=plugin/src/create-schema-customization.ts
import type { GatsbyNode } from "gatsby"

export const createSchemaCustomization: GatsbyNode[`createSchemaCustomization`] =
  ({ actions }) => {
    const { createTypes } = actions

    createTypes(`
      type Post implements Node {}

      type Author implements Node {}
    `)
  }
```

Try to add the fields for both root node types. Can you figure it out by inspecting the data shape used in `source-nodes.ts`? Don't worry if not, you can use the solution below.

<Collapsible
  summary={<em>Show me the solution</em>}
>

```ts:title=plugin/src/create-schema-customization.ts
import type { GatsbyNode } from "gatsby"

export const createSchemaCustomization: GatsbyNode[`createSchemaCustomization`] =
  ({ actions }) => {
    const { createTypes } = actions

    createTypes(`
      type Post implements Node {
        id: ID!
        _id: Int!
        slug: String!
        title: String!
        author: String!
        image: PostImage!
      }

      type Author implements Node {
        id: ID!
        _id: Int!
        name: String!
      }

      type PostImage {
        url: String!
        alt: String!
        width: Int!
        height: Int!
      }
    `)
  }
```

</Collapsible>

<Announcement>

**Pro tip:** If you use the [GraphQL Typegen](/docs/how-to/local-development/graphql-typegen/) option, during `gatsby develop` the file `.cache/typegen/schema.graphql` will be generated. This is the current GraphQL schema inside Gatsby and you can use it to copy/paste types.

You can also use the [documentation explorer in GraphiQL](/docs/tutorial/part-4/#use-graphiql-to-explore-the-data-layer-and-write-graphql-queries) to figure out the exact shape of GraphQL types.

</Announcement>

## Add a foreign-key relationship

TODO

- Between `Post` and `Author`

## Summary

TODO

### Key takeaways

TODO

<Announcement>

**Share Your Feedback!**

Our goal is for this tutorial to be helpful and easy to follow. We'd love to hear your feedback about what you liked or didn't like about this part of the tutorial.

Use the "Was this doc helpful to you?" form at the bottom of this page to let us know what worked well and what we can improve.

</Announcement>

### What's coming next?

TODO

<LinkButton
  to="/docs/tutorial/creating-a-source-plugin/part-4/"
  rightIcon={<MdArrowForward />}
  variant="SECONDARY"
>
  Continue to Part 4
</LinkButton>