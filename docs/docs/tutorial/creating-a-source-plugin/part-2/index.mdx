---
title: "Part 2: Create Nodes"
---

import { LinkButton } from "gatsby-interface"
import Collapsible from "@components/collapsible"
import { MdArrowForward } from "react-icons/md"

## Introduction

Time to get started with implementing the core part of a source plugin!

Gatsby exposes many [Gatsby Node APIs](/docs/reference/config-files/gatsby-node/) (some people also refer to such APIs as "hooks") that allow anyone, including source plugins, to hook into Gatsby's build process. You could create pages, modify the bundler configuration, or in the case of a source plugin add data to Gatsby's GraphQL data layer.

In this part of the tutorial, you'll learn how to use the `sourceNodes` Node API.

By the end of this part of the tutorial, you will be able to:

- Fetch data from an external backend API
- Insert that data into Gatsby's GraphQL data layer
- Display your results inside a Gatsby site

The diagram below shows a high-level view of how a Gatsby source plugin works. (Don't worry if this doesn't make sense yet. You'll learn about each step as you go.)

TODO: Insert diagram showing the API => sourceNodes => createNode => Show in page flow (like part1 main tutorial)

## Source data from an API

Before making changes to your plugin, double check that you're running the `develop:deps` script in your terminal (or more general: That you're recompiling your plugin on changes). Otherwise you'll wonder why you don't see your changes reflected in your example site (don't ask how we know).

### Add `sourceNodes` lifecycle

Create a new file called `source-nodes.ts` inside the plugin's `src` folder with a named `sourceNodes` export:

```ts:title=plugin/src/source-nodes.ts
import type { GatsbyNode } from "gatsby"

export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
  const { reporter } = gatsbyApi

  reporter.info(`Example plugin sourceNodes...`)
}
```

You're importing the TypeScript type `GatsbyNode` from `gatsby`. The `GatsbyNode` type is a representation of all available Gatsby Node APIs and you can access each type with the bracket notation, e.g. you'd get the TypeScript type for the `onPluginInit` API like this: ``GatsbyNode[`onPluginInit`]``.

Each Gatsby Node API receives its available [Node API helpers](/docs/reference/config-files/node-api-helpers/) as its first parameter, the plugin's options is the second parameter to the function.

In the example above you're adding a log to the terminal output for initial testing purposes. You'll learn more about plugin options and the `reporter` API in [Part 4](/docs/tutorial/creating-a-source-plugin/part-4/).

<Announcement>

**Pro tip:** You're not immediately destructuring the Node API helpers in the function, but only in the function body. This way you'll be able to more easily pass `gatsbyApi` to utility functions.

A destructured version would look like this:

```ts
export const sourceNodes: GatsbyNode[`sourceNodes`] = async ({ reporter }) => {
  reporter.info(`Example plugin sourceNodes...`)
}
```

The problem with this is that if you want to pass `reporter` or any other helper to a utility function, you'll always need to update all function parameters when you add/remove a helper. `gatsbyApi` contains everything and inside the helper function you can access what you need. You'll see this applied in just a bit.

</Announcement>

Next, add the `sourceNodes` export to the plugin's `gatsby-node.ts`. Gatsby checks for named exports in `gatsby-node` file, and only when those are given it runs the different Node APIs.

```ts:title=plugin/src/gatsby-node.ts
export type { IPluginOptions } from "./types"

export { onPluginInit } from "./on-plugin-init"
// highlight-next-line
export { sourceNodes } from "./source-nodes"
```

In a second terminal window run (or restart if it's still running) the `develop:site` script:

```shell
yarn develop:site
```

You should see the new log `info Example plugin sourceNodes...` printed to the terminal.

### Fetch data

Now that you've learned how to add the `sourceNodes` API to your plugin, it's time to do more than just outputting a message.

Open the `source-nodes.ts` file, remove the previous `reporter` usage, and import the `fetchGraphQL` utility. You'll use it to make requests against the example GraphQL API and it returns an object containing `data` and `errors`.

```ts:title=plugin/src/source-nodes.ts
import type { GatsbyNode } from "gatsby"
import { fetchGraphQL } from "./utils"

export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
  const { data, errors } = await fetchGraphQL(
    `http://localhost:4000/graphql`,
    ``
  )
}
```

The first argument to `fetchGraphQL` is the endpoint, the second argument is the GraphQL query you want to make against the API.

<Collapsible
  summary={<em>Working with a remote backend API</em>}
>

The topic of "working with a remote backend API" is a really broad topic and not something we can cover here in its entirety as part of this tutorial. However, here are some comments and tips that will help you while working on your plugin:

- Feel free to either use a barebones fetch function (via [`node-fetch`](https://www.npmjs.com/package/node-fetch)) or something more batteries-included like [`got`](https://www.npmjs.com/package/got). It depends on your API, e.g. if its unreliable, add retry logic to your fetching. If it's your small API that you know, a more barebones approach will probably be just fine.
- Check if the source you're trying to access has its own SDK. Many CMSs have their own SDK, e.g. Contentful with their [`contentful`](https://www.npmjs.com/package/contentful) package. When available, we'd recommend using these first.
- It's good practice to gracefully handle errors when trying to access a remote API. This includes errors directly from the API but also ones like sudden internet connection loss. You don't want to silently fail on such errors but show them to the user of your plugin.

You can also explore the API if you're not familiar with it or have it written yourself. For example, you can visit `http://localhost:4000/graphql` to explore the example API of this tutorial. It's a fully functional GraphiQL IDE window and with its help you can create your queries and test them.

</Collapsible>

Add the GraphQL query to the second parameter of `fetchGraphQL` and add the correct TypeScript types:

```ts:title=plugin/src/source-nodes.ts
import type { GatsbyNode } from "gatsby"
import { fetchGraphQL } from "./utils"
// highlight-next-line
import type { IAuthorInput, IPostInput } from "./types"

export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
  // highlight-start
  interface IApiResponse {
    data: {
      posts: Array<IPostInput>
      authors: Array<IAuthorInput>
    }
    errors?: Array<{
      message: string
      locations: Array<unknown>
    }>
  }
  // highlight-end

  const { data, errors } = await fetchGraphQL<IApiResponse>(
    `http://localhost:4000/graphql`,
    // highlight-start
    `query FetchApi {
      posts {
        id
        slug
        title
        image {
          url
          alt
          width
          height
        }
        author
      }
      authors {
        id
        name
      }
    }
    `
    // highlight-end
  )
}
```

To see if you can successfully source the data from the API, `console.dir` the `data` result:

```ts:title=plugin/src/source-nodes.ts
// Imports...

export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
  // Rest of the code ...

  console.dir(data, { depth: null })
}
```

<Announcement>

**Pro tip:** If you'd use `console.log(data)` (feel free to try it), not the whole depth of the object will be shown. You can instead use `console.dir` with a `depth` setting to display everything.

</Announcement>

Restart the `develop:site` script and if everything worked correctly, you should see something like this in your terminal output:

```shell
{
  posts: [
    {
      id: '1',
      slug: 'post-1',
      title: 'The first post',
      image: {
        url: 'https://images.unsplash.com/photo-1615751072497-5f5169febe17?fm=jpg',
        alt: 'brown and white long coated dog',
        width: 3024,
        height: 4032
      },
      author: 'Jay Gatsby'
    },
    {
      id: '2',
      slug: 'post-2',
      title: 'The second post',
      image: {
        url: 'https://images.unsplash.com/photo-1591160690555-5debfba289f0?fm=jpg',
        alt: 'golden retriever puppy on focus',
        width: 5394,
        height: 6743
      },
      author: 'Jay Gatsby'
    },
    {
      id: '3',
      slug: 'post-3',
      title: 'The third post',
      image: {
        url: 'https://images.unsplash.com/photo-1547525623-c7d42c20284c?fm=jpg',
        alt: 'long fur white dog on grass',
        width: 4000,
        height: 6000
      },
      author: 'Daisy Buchanan'
    }
  ],
  authors: [
    { id: '1', name: 'Jay Gatsby' },
    { id: '2', name: 'Daisy Buchanan' }
  ]
}
warn The plugin plugin has generated no Gatsby nodes. Do you need it? This could also suggest the plugin is misconfigured.
```

This means that you can successfully access data from the example API! Gatsby is smart enough to notice that you run a plugin with a `sourceNodes` API but that it doesn't generate any nodes. That's why the warning is showing up. You'll fix this in the next step.

## Create GraphQL nodes

Before immediately diving into the node creation process, take a step back and think through what you want to create from `data` inside Gatsby. While in the scope of this tutorial the question is simpler to answer (nodes of type `Post` and `Author`), this won't be the case for every API you'll work with. Inspect the data that is available, think of fitting node types and their relationships, and write it down. Only after doing that start writing actual code.

As an example:

- You're requesting the REST API endpoint called `/authors` and it gives you back a list of authors, each with a unique ID. However, this API response doesn't contain the details for each author, instead you're supposed to call `/author/<author-id>` to request additional information.
- The strict 1:1 mapping of API endpoints to node types would mean you'd have `Author` and `AuthorDetail`
- But you shouldn't create `Author` and `AuthorDetail` node types but instead only a `Author` one. While creating the `Author` one, access the information from the author detail endpoint and enrich the `Author` information.

<Announcement>

**Need a refresher on what "nodes" are?** Don't worry!

Inside the Gatsby's data layer, information is stored in objects called **nodes**. A node is the smallest form unit of data in the data layer. Different source plugins create different types of nodes, each of which have their own properties. For example, `gatsby-source-filesystem` creates `File` nodes.

Also be sure to checkout the [GraphQL concepts](/docs/conceptual/graphql-concepts/) page if you need more information.

</Announcement>

### Define constants

Since you'll need to use the name of your node types in a couple of places, it's easy to introduce typos while using them. Create a `constants.ts` file to define your names once and reuse them everywhere. This way you can also more easily change the names after the fact. Neat!

Add the following to your new `constants.ts` file:

```ts:title=plugin/src/constants.ts
export const NODE_TYPES = {
  Post: `Post`,
  Author: `Author`,
} as const
```

For the next step you'll also need some additional TypeScript types, so go ahead and add the following to the `types.ts` file:

```ts:title=plugin/src/types.ts
// Rest of imports...
import { NODE_TYPES } from "./constants"

export type NodeBuilderInput =
  | { type: typeof NODE_TYPES.Author; data: IAuthorInput }
  | { type: typeof NODE_TYPES.Post; data: IPostInput }

// Rest of types...
```

You're setting up [Discriminated Unions](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions) here which will be used as the input type for the `nodeBuilder` utility. It ensure that e.g. with `type: "Author"` only the `data` in the shape of `IAuthorInput` can be passed in.

### Create `nodeBuilder` utility

You'll create a utility function called `nodeBuilder` and its purpose is to take in data, mutate it (if necessary), and then call [`createNode`](/docs/reference/config-files/actions/#createNode) for each node type with its respective data. You're then calling `nodeBuilder` for each of your entries from the API response, filling Gatsby's data store with the data from the example API.

A basic usage of `createNode` looks like this:

```ts:title=gatsby-node.ts
import type { GatsbyNode } from "gatsby"

export const sourceNodes: GatsbyNode[`sourceNodes`] = (gatsbyApi) => {
  // Your arbitrary, serializable data
  const yourData = {
    hello: `world`,
  }

  const node = {
    ...yourData,
    // Required fields
    id: gatsbyApi.createNodeId(`some-string`),
    parent: null,
    children: [],
    internal: {
      type: `TypeName`,
      contentDigest: gatsbyApi.createContentDigest(yourData)
    }
  }

  gatsbyApi.actions.createNode(node)
}
```

<Collapsible
  summary={<em>Explanation on each required node field</em>}
>

Here's a short explanation on each required field for your convenience:

- `id`: The node's ID that Gatsby uses to track it. It must be a globally unique ID. You should use the [`createNodeId`](/docs/reference/config-files/node-api-helpers/#createNodeId) helper to create it.
- `parent`: If a node is derived from another node, set the ID of the parent node here. Otherwise it can just be `null`.
- `children`: You can place node IDs from child nodes here, if necessary. Most often you'll see yourself using `createParentChildLink`.
- `internal`: An object that only allows a defined set of keys (see API reference)
  - `type`: The name of the node type
  - `contentDigest`: A hash (or short digital summary) of the conents of a node. The digest should be unique to the content of the node since it's used for caching. If the content changes, this digest should also change. Use the [`createContentDigest`](/docs/reference/config-files/node-api-helpers/#createContentDigest) helper to create that hash.

You can use the [`createNode` API reference](/docs/reference/config-files/actions/#createNode) in the future if you're creating more advanced node types, e.g. ones where you have to define the `mediaType`.

</Collapsible>

Afterwards one is able to query the `TypeName` type with a `hello` key:

```graphql
query {
  typeName {
    hello
  }
}
```

Now that you know how a barebones version of `createNode` works, DRY (acronym for "Do not repeat yourself") things up by creating the `nodeBuilder` function inside `source-nodes.ts`. Import the `SourceNodesArgs` and `NodeInput` type from `gatsby` and the `NodeBuilderInput` type from `types.ts`:

```ts:title=plugin/src/source-nodes.ts
// highlight-next-line
import type { GatsbyNode, SourceNodesArgs, NodeInput } from "gatsby"
import { fetchGraphQL } from "./utils"
// highlight-next-line
import type { IAuthorInput, IPostInput, NodeBuilderInput } from "./types"

export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
  // Contents of sourceNodes...
}

// highlight-start
interface INodeBuilderArgs {
  gatsbyApi: SourceNodesArgs
  input: NodeBuilderInput
}

function nodeBuilder({ gatsbyApi, input }: INodeBuilderArgs) {}
// highlight-end
```

<Announcement>

**TypeScript tip:** The `gatsbyApi` that a Gatsby Node API receives isn't always the same on each Node API. Therefore types in the naming scheme "Node API name" (in PascalCase) + "Args" exist, e.g. `sourceNodes` => `SourceNodesArgs`, `createSchemaCustomization` => `CreateSchemaCustomizationArgs`. Those utility TypeScript types are helpful when passing `gatsbyApi` or parts of it to another function.

</Announcement>

Apply the same logic as the barebones `createNode` example to the `nodeBuilder` function now, so:

- Generate a unique `id`, dependend on the `input.type` and `id` from `input.data`
- Fill out the necessary fields on the node (as explained in "Explanation on each required node field" above)
- Add your arbitrary data (in this case `...input.data`)
- Call `createNode`

```ts:title=plugin/src/source-nodes.ts
// Rest of the file...

function nodeBuilder({ gatsbyApi, input }: INodeBuilderArgs) {
  const id = gatsbyApi.createNodeId(`${input.type}-${input.data.id}`)

  const node = {
    ...input.data,
    id,
    _id: input.data.id,
    parent: null,
    children: [],
    internal: {
      type: input.type,
      contentDigest: gatsbyApi.createContentDigest(input.data),
    },
  } satisfies NodeInput

  gatsbyApi.actions.createNode(node)
}
```

Great, you wrote a reusable helper function to create nodes! Now it's time to put it to use.

<Announcement>

**Pro tip:** If your incoming data has keys that clash with fields reserved by Gatsby (in this example `id`), you can prefix those fields to still make them available. So the `id` coming from the example API will be available at `_id`. You don't have to use a `_` prefix, you can choose whatever you want (but we'd recommend keeping things consistent).

</Announcement>

Scroll up in `source-nodes.ts` to the place where you're calling `console.dir()` and remove that log. Replace it with a destructuring assignment of `data` to get the `posts` and `authors` results out of it (you can also set an empty array as a default value):

```ts:title=plugin/src/source-nodes.ts
// Rest of the file...

export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
  // Rest of sourceNodes...

  const { posts = [], authors = [] } = data
}
```

So both `posts` and `authors` are an array of objects that you should iterate over. Each object will become a Gatsby node. Iterate over both arrays and call `nodeBuilder` inside the loops:

```ts:title=plugin/src/source-nodes.ts
// Rest of the file...

export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
  // Rest of sourceNodes...

  const { posts = [], authors = [] } = data

  // highlight-start
  for (const post of posts) {
    nodeBuilder({ gatsbyApi, input: { type: `Post`, data: post } })
  }

  for (const author of authors) {
    nodeBuilder({ gatsbyApi, input: { type: `Author`, data: author } })
  }
  // highlight-end
}
```

## Display results in your site

TODO

## Summary

TODO

### Key takeaways

TODO

<Announcement>

**Share Your Feedback!**

Our goal is for this tutorial to be helpful and easy to follow. We'd love to hear your feedback about what you liked or didn't like about this part of the tutorial.

Use the "Was this doc helpful to you?" form at the bottom of this page to let us know what worked well and what we can improve.

</Announcement>

### What's coming next?

TODO

<LinkButton
  to="/docs/tutorial/creating-a-source-plugin/part-3/"
  rightIcon={<MdArrowForward />}
  variant="SECONDARY"
>
  Continue to Part 3
</LinkButton>