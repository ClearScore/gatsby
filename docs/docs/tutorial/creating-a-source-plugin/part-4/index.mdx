---
title: "Utilities"
---

import { LinkButton } from "gatsby-interface"
import Collapsible from "@components/collapsible"
import { MdArrowForward } from "react-icons/md"

## Introduction

In the previous parts you built the foundation of your source plugin, from now on it's about adding new functionalities, improving the user experience, and making the plugin overall better.

This part of the tutorial will focus on a subset of the [Node API helpers](/docs/reference/config-files/node-api-helpers/). Feel free to revisit this document as it can also work as standalone instructions for those APIs.

By the end of this part of the tutorial, you will be able to:

- Use the `reporter` API to output structured terminal messages
- Use the `cache` API to save artifacts between runs
- Use the `pluginOptionsSchema` API to verify your plugin's options
- Define custom errors for your plugin through `reporter.setErrorMap`

## `reporter` API

You, as a source plugin author, can interact with your users in a variety of ways. You can share information in the README, chat in issues & PRs, create guides etc. But you or rather your source plugin will interact the most with your users through the terminal when they run `gatsby develop` or `gatsby build`. Gatsby outputs what it does behind the scenes with the goal of giving the users rich information that helps them be more productive with Gatsby itself.

For this, Gatsby internally uses the `reporter` API and you can use it, too! When adding logs to the terminal be mindful of keeping of them concise, informative, and to a minimum. Most Gatsby plugins don't even need to add logs (other than errors), so in doubt leave them out at the beginning and reevaluate once you have a bigger user base.

If you need information about an API, always be sure to check Gatsby's API docs, in this case the [reporter API docs](/docs/reference/config-files/node-api-helpers/#reporter). The `reporter` API is available in all Node APIs and its methods can be used like this:

```ts
// Doesn't have to only be onPluginInit, any Node API has it
export const onPluginInit = ({ reporter }) => {
  reporter.info(`Hello World!`)
}
```

Here's a short explainer on the most important methods:

- `info`: Print a message to the terminal.
- `warn`: Print a warning message to the terminal.
- `error`: Print an error message to the terminal.
- `panic`: Print an error message to the terminal and immediately exit the process.
- `panicOnBuild`: Print an error message to the terminal and immediately exit the process (only during `gatsby build`). Most often you should use this over `panic` as it'll allow users to debug the error during `gatsby develop`.
- `verbose`: Print a message to the terminal that is only visible when the "verbose" flag is enabled (e.g. `gatsby build --verbose`).
- `activityTimer`: Print an informational message to the terminal that has a timer attached to it (e.g. how long that step took).
- `setErrorMap`: Set a custom error map to the reporter. This allows the reporter to extend Gatsby's internal error map.

You'll learn how to use `panicOnBuild`, `activityTimer`, and `setErrorMap` in the next three tasks as they are the most relevant and common for plugins.

### Task: Output errors

As source plugins interact with third-party APIs they are inherently prone to errors (network issues, API outages, etc.). As explained in [Part 2](/docs/tutorial/creating-a-source-plugin/part-2/#fetch-data) it's good practice to gracefully handle all possible error states, as there's nothing worse than no actionable feedback at all.

In Part 2 you also added the `fetchGraphQL` function that accesses the GraphQL API inside the `api` folder. When you send a malformed request to it, it can not only give back `data` but also `errors`. Use that information to output it with `panicOnBuild`.

1. Go to your `plugin/src/source-nodes.ts` file. Destructure `reporter` from `gatsbyApi` at the top of `sourceNodes`. Add `errors` to the destructuring statement for the `fetchGraphQL` response. Also add a conditional statement when `errors` is truthy directly below `fetchGraphQL`:

    ```ts:title=plugin/src/source-nodes.ts
    // Imports

    export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
      // highlight-next-line
      const { reporter } = gatsbyApi

      // Types

      // highlight-next-line
      const { data, errors } = await fetchGraphQL<IApiResponse>(
        `http://localhost:4000/graphql`,
        `query FetchApi {
          posts {
            id
            slug
            title
            image {
              url
              alt
              width
              height
            }
            author
          }
          authors {
            id
            name
          }
        }
        `
      )

      // highlight-start
      if (errors) {
        // Do something...
      }
      // highlight-end

      // Rest of sourceNodes
    }

    // Rest of file
    ```

1. Inside the `errors` conditional, use `panicOnBuild` to output the error message that you're receiving from your API. `error`, `panicOnBuild`, and `panic` accept a `string`, `Error` or a structured error (you'll learn about the latter in [Task: Define custom errors](#task-define-custom-errors)).

    ```ts:title=plugin/src/source-nodes.ts
    // Imports

    export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
      // Rest of sourceNodes

      if (errors) {
        // highlight-next-line
        reporter.panicOnBuild(errors[0].message)
      }

      // Rest of sourceNodes
    }

    // Rest of file
    ```

1. To see if it works, add a typo to your GraphQL request inside `fetchGraphQL`:

    ```ts:title=plugin/src/source-nodes.ts
    const { data, errors } = await fetchGraphQL<IApiResponse>(
      `http://localhost:4000/graphql`,
      `query FetchApi {
        posts {
          id
          slug
    // highlight-next-line
          title2
          image {
            url
            alt
            width
            height
          }
          author
        }
        authors {
          id
          name
        }
      }
      `
    )
    ```

    Restart the `develop:site` script and you should see an error in the terminal:

    ```shell
    ERROR  UNKNOWN

    Cannot query field "title2" on type "Post". Did you mean "title"?
    ```

    Yes, it works ðŸŽ‰ Don't forget to remove the typo again. In [Task: Define custom errors](#task-define-custom-errors) you'll learn how to further customize this error.

You're now surfacing any errors that occur during the data fetching to your users. Use the `error`, `panicOnBuild, and `panic` methods throughout your code to display all relevant errors to your user.

**Please note:** If necessary, add context to your error messages instead of only passing the error along. This is especially true if the error could be thrown in multiple places or if the original error is not clear enough.

### Task: Show activities and timings

Since your source plugin is retrieving information from a third-party API the process of doing that could take a while, especially if it's fetching a lot of data. In these instances you can use the `activityTimer` method to let the user know that something is happening in the background. You shouldn't add separate `activityTimer` instances (remember: Keep the output concise and to a minimum) but instead use the `setStatus` method on `activityTimer` to update its text.

You'll now exactly learn that by adding an activity for the sourcing and node creation process of your plugin.

1. Create a new `activityTimer` and store that in a variable (the name doesn't matter). You'll use the variable to start, update, and stop the timer.

    ```ts:title=plugin/src/source-nodes.ts
    // Imports

    export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
      const { reporter } = gatsbyApi

      const sourcingTimer = reporter.activityTimer(`Sourcing from plugin API`)

      // Rest of sourceNodes
    }

    // Rest of file
    ```

1. Since the `sourcingTimer` was initialized before the `fetchGraphQL` call you can also `start()` it before that call:

    ```ts:title=plugin/src/source-nodes.ts
    // Imports

    export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
      const { reporter } = gatsbyApi

      const sourcingTimer = reporter.activityTimer(`Sourcing from plugin API`)
      // highlight-next-line
      sourcingTimer.start()

      // Rest of sourceNodes
    }

    // Rest of file
    ```

    With the `start()` call the timer is running until you'll eventually call `end()`.

1. If the sourcing fails, the timer should be stopped. So update the `panicOnBuild` call to use the `sourcingTimer` instead:

    ```ts:title=plugin/src/source-nodes.ts
    // Imports

    export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
      // Rest of sourceNodes

      if (errors) {
        // highlight-next-line
        sourcingTimer.panicOnBuild(errors[0].message)
      }

      // Rest of sourceNodes
    }

    // Rest of file
    ```

1. Right now the `sourcingTimer` shows "Sourcing from plugin API" together with a time in seconds. You can use the `setStatus()` method to append text.

    ```ts:title=plugin/src/source-nodes.ts
    // Imports

    export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
      // Rest of sourceNodes

      const { posts = [], authors = [] } = data

      // highlight-start
      sourcingTimer.setStatus(
        `Processing ${posts.length} posts and ${authors.length} authors`
      )
      // highlight-end

      for (const post of posts) {
        nodeBuilder({ gatsbyApi, input: { type: `Post`, data: post } })
      }

      for (const author of authors) {
        nodeBuilder({ gatsbyApi, input: { type: `Author`, data: author } })
      }
    }

    // Rest of file
    ```

    <Announcement>

    **Pro tip:** Adding the information of how many types were created is a really nice debugging help since it'll allow folks to quickly compare builds and see if e.g. all the information they expect is sourced.

    </Announcement>

1. Stop the timer once node creation is done:

    ```ts:title=plugin/src/source-nodes.ts
    // Imports

    export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
      // Rest of sourceNodes

      const { posts = [], authors = [] } = data

      sourcingTimer.setStatus(
        `Processing ${posts.length} posts and ${authors.length} authors`
      )

      for (const post of posts) {
        nodeBuilder({ gatsbyApi, input: { type: `Post`, data: post } })
      }

      for (const author of authors) {
        nodeBuilder({ gatsbyApi, input: { type: `Author`, data: author } })
      }

      // highlight-next-line
      sourcingTimer.end()
    }

    // Rest of file
    ```

1. Restart the `develop:site` script and you should read a new activity in the terminal:

    ```shell
    success Sourcing from plugin API - 0.019s - Processing 3 posts and 2 authors
    ```

    That's what we'd expect, nice!

### Task: Define custom errors

The error you've output to the terminal in [Task: Output errors](#task-output-errors) was functional but missing some crucial information. Where is the error coming from? Which part of the plugin? Any suggestions for immediate fixes?

You can use the `setErrorMap` method to create an error map for your plugin. Gatsby internally uses an error map to benefit from two things (among other additional benefits):

- A user can google the error with its unique ID and hopefully only find resources that are directly related to that error.
- One can track down the location in the source code where an error is thrown quicker through the use of constants and unique IDs.

Both benefits also apply to you when you define a custom error map for your plugin. You'll see the improvement at the end of this task. As a reminder, this is how an error (for the data fetching step) currently looks like:

```shell
ERROR  UNKNOWN

Cannot query field "title2" on type "Post". Did you mean "title"?
```

Let's get to work:

1. Open the `plugin/src/constants.ts` file and add an `ERROR_CODES` map with its first key `GraphQLSourcing`:

    ```ts:title=plugin/src/constants.ts
    export const NODE_TYPES = {
      Post: `Post`,
      Author: `Author`,
    } as const

    // highlight-start
    export const ERROR_CODES = {
      GraphQLSourcing: `10000`,
    } as const
    // highlight-end
    ```

    The keys of the `ERROR_CODES` object can be arbitrary, we'd recommend using names that make it easy to differentiate them for their different purposes. The value of each entry is the unique ID. So make sure that each ID only exists once inside `ERROR_CODES`.

    You don't need to worry about other plugins or Gatsby itself as the IDs are namespaced with your plugin. If possible, use IDs that are not already used by Gatsby itself.

1. Import `ERROR_CODES` into `plugin/src/on-plugin-init.ts` and initialize `setErrorMap`. Remove the existing `info` call:

    ```ts:title=plugin/src/on-plugin-init.ts
    import type { GatsbyNode } from "gatsby"
    // highlight-next-line
    import { ERROR_CODES } from "./constants"

    export const onPluginInit: GatsbyNode[`onPluginInit`] = ({ reporter }) => {
      // highlight-next-line
      reporter.setErrorMap({})
    }
    ```

1. You can populate the error map like so:

    - The object's keys are the unique IDs
    - The object should contain these three keys and values:
      - `text`: Your text that will be shown to the user for this specific error
      - `level`: Set this to `ERROR`
      - `category`: Set this to `THIRD_PARTY`

    Add the following to `plugin/src/on-plugin-init.ts`:

    ```ts:title=plugin/src/on-plugin-init.ts
    import type { GatsbyNode } from "gatsby"
    import { ERROR_CODES } from "./constants"

    export const onPluginInit: GatsbyNode[`onPluginInit`] = ({ reporter }) => {
      reporter.setErrorMap({
        [ERROR_CODES.GraphQLSourcing]: {
          text: (context) => `${context.sourceMessage}: ${context.graphqlError}`,
          level: `ERROR`,
          category: `THIRD_PARTY`,
        },
      })
    }
    ```

    `text` has to be a function that returns a `string` and receives a freeform `context`. You can pass through any information you'd like in `context` and then use it to construct the final message that is shown to the user. So the error above requires `sourceMessage` and `graphqlError` to work.

1. In this step you'll invoke the error with the custom ID and pass along the required `context` information. Open `plugin/src/source-nodes.ts` and add the `ERROR_CODES` import and use it inside the existing `panicOnBuild` call:

    ```ts:title=plugin/src/source-nodes.ts
    import type { GatsbyNode, SourceNodesArgs, NodeInput } from "gatsby"
    import { fetchGraphQL } from "./utils"
    import type { IAuthorInput, IPostInput, NodeBuilderInput } from "./types"
    // highlight-next-line
    import { ERROR_CODES } from "./constants"

    export const sourceNodes: GatsbyNode[`sourceNodes`] = async (gatsbyApi) => {
      // Rest of sourceNodes

      if (errors) {
        sourcingTimer.panicOnBuild({
          id: ERROR_CODES.GraphQLSourcing,
          context: {
            sourceMessage: `Sourcing from the GraphQL API failed`,
            graphqlError: errors[0].message,
          },
        })
      }

      // Rest of sourceNodes
    }

    // Rest of file
    ```

1. As in step 3 of [Task: Output errors](#task-output-errors), add a typo to the GraphQL error again (e.g. `title2`), restart the `develop:site` script and you should see a new output for the error:

    ```shell
    ERROR #plugin_10000  PLUGIN

    Sourcing from the GraphQL API failed: Cannot query field "title2" on type "Post". Did you mean "title"?

    failed Sourcing from plugin API - 0.029s
    ```

## `cache` API

TODO

### Task: Save the timestamp of last sourcing

TODO

## `pluginOptionsSchema` API

TODO

### Task: Verify your plugin's options

TODO

## Summary

TODO

### Key takeaways

TODO

<Announcement>

**Share Your Feedback!**

Our goal is for this tutorial to be helpful and easy to follow. We'd love to hear your feedback about what you liked or didn't like about this part of the tutorial.

Use the "Was this doc helpful to you?" form at the bottom of this page to let us know what worked well and what we can improve.

</Announcement>

### What's coming next?

TODO

<LinkButton
  to="/docs/tutorial/creating-a-source-plugin/part-5/"
  rightIcon={<MdArrowForward />}
  variant="SECONDARY"
>
  Continue to Part 5
</LinkButton>